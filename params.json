{"name":"Iron-router","tagline":"Routing designed specifically for Meteor.","body":"# Iron Router\r\n\r\nA client and server side router designed specifically for Meteor.\r\n\r\n**Table of Contents**\r\n\r\n- [Key Concepts](#key-concepts)\r\n  - [Named Routes](#named-routes)\r\n  - [Route Options](#route-options)\r\n  - [Route Paths and Parameters](#route-paths-and-parameters)\r\n  - [Dynamic Path Segments](#dynamic-path-segments)\r\n  - [Query Strings and Hash Segments](#query-strings-and-hash-segments)\r\n- [Client Side Routing](#client-side-routing)\r\n  - [Rendering the Router](#rendering-the-router)\r\n  - [Path Functions and Helpers](#path-functions-and-helpers)\r\n  - [Changing routes programmatically](#changing-routes-programmatically)\r\n  - [Rendering Templates](#rendering-templates)\r\n  - [Using a Layout with Yields](#using-a-layout-with-yields)\r\n  - [Data](#data)\r\n  - [Waiting on Subscriptions (waitOn)](#waiting-on-subscriptions-waiton)\r\n  - [Waiting on Subscriptions (wait)](#waiting-on-subscriptions-wait)\r\n  - [Using a Custom Action Function](#using-a-custom-action-function)\r\n  - [Custom Rendering](#custom-rendering)\r\n  - [Using hooks](#using-hooks)\r\n  - [Before and After Hooks](#before-and-after-hooks)\r\n  - [Unload Hook](#unload-hook)\r\n  - [Global Router Configuration](#global-router-configuration)\r\n- [Server Side Routing](#server-side-routing)\r\n- [Route Controllers](#route-controllers)\r\n- [Examples](#examples)\r\n  - [Parsing Url Parameters (OAuth Example)](#parsing-url-parameters-oauth-example)\r\n\r\n## Key Concepts\r\nOnce you add the iron-router package the global `Router` object is available on\r\nthe client and on the server. So you can create your routes and configure the\r\nrouter outside of your `Meteor.isClient` and `Meteor.isServer` blocks. Or, if\r\nyou are only going to be using client side routes, it's okay to put the routing\r\ncode in your `client/` folder.\r\n\r\n### Named Routes\r\nYou can declare a named route like this:\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('home');\r\n});\r\n```\r\n\r\nThis creates a route with the name \"home\". The route is named so that you can\r\nquickly get the route by name like this: `Router.routes['home']`. \r\n\r\nBy default, routes are created as client routes. This means, the route will only\r\nbe run on the client, and not the server. When you click a link that maps to a\r\nclient side route, the route will be completely run in the browser without\r\nmaking a trip to the server. If you click a link that maps to a server route,\r\nthe browser will make a server request and the server side router will handle\r\nthe link. More information on server side routes is provided below.\r\n\r\n### Route Options\r\nYou'll typically provide options to your route. At the very least, you'll tell\r\nthe route what `path` it should match. You provide options to the route by\r\npassing an object as the second parameter to `this.route` like this:\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('home', {\r\n    /* options will go here */\r\n  });\r\n});\r\n```\r\n\r\n### Route Paths and Parameters\r\nThe first option you will almost always provide to the route is a `path`. By\r\ndefault, the route will use its own name for the path. For example given the\r\nfollowing route:\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('home');\r\n});\r\n```\r\nThe route will map to the path `/home`. But you'll likely want to provide a\r\ncustom path. You can provide a custom path like this:\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('home', {\r\n    path: '/' // match the root path\r\n  });\r\n});\r\n```\r\n\r\nWhen the url changes, the Router looks for the first Route that matches the\r\ngiven url path. In this example, when the application first loads, the url will\r\nbe: `http://localhost:3000/` and the `home` route will match this path.\r\n\r\n### Dynamic Path Segments\r\nPaths get compiled into a regular expression and can support dynamic segments.\r\nYou can even use a regular expression as your path value. The values of these\r\nparams are made available inside of any route functions using\r\n`this.params`. You'll see examples of different route functions below. But to\r\nget us started, here are a few examples of dynamic paths:\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  // No Parameters\r\n  this.route('posts', {\r\n    // matches: '/posts'\r\n    // redundant since the name of the route is posts\r\n    path: '/posts' \r\n  }); \r\n\r\n  // One Required Parameter\r\n  this.route('postShow', {\r\n    // matches: '/posts/1'\r\n    path: '/posts/:_id' \r\n  });\r\n\r\n  // Multiple Parameters\r\n  this.route('twoSegments', {\r\n    // matches: '/posts/1/2'\r\n    // matches: '/posts/3/4'\r\n    path: '/posts/:paramOne/:paramTwo'\r\n  });\r\n\r\n  // Optional Parameters\r\n  this.route('optional', {\r\n    // matches: '/posts/1'\r\n    // matches: '/posts/1/2'\r\n    path: '/posts/:paramOne/:optionalParam?'\r\n  });\r\n\r\n  // Anonymous Parameter Globbing \r\n  this.route('globbing', {\r\n    // matches: '/posts/some/arbitrary/path'\r\n    // matches: '/posts/5'\r\n    // route globs are available\r\n    path: '/posts/*'\r\n  });\r\n\r\n  // Named Parameter Globbing\r\n  this.route('namedGlobbing', {\r\n    // matches: '/posts/some/arbitrary/path'\r\n    // matches: '/posts/5'\r\n    // stores result in this.params.file\r\n    path: '/posts/:file(*)'\r\n  });\r\n\r\n  // Regular Expressions\r\n  this.route('regularExpressions', {\r\n    // matches: '/commits/123..456'\r\n    // matches: '/commits/789..101112'\r\n    path: /^\\/commits\\/(\\d+)\\.\\.(\\d+)/\r\n  });\r\n});\r\n```\r\n\r\n### Query Strings and Hash Segments\r\nQuery strings and hashes aren't used to match routes. But they are made\r\navailable as properties of `this.params` inside of your route functions. We\r\nhaven't talked about the various route functions yet, but here is an example:\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('postShow', {\r\n    path: '/posts/:_id',\r\n    data: function () {\r\n      // the data function is an example where this.params is available\r\n\r\n      // we can access params using this.params\r\n      // see the below paths that would match this route\r\n      var params = this.params;\r\n\r\n      // query params are added as normal properties to this.params.\r\n      // given a browser path of: '/posts/5?sort_by=created_at\r\n      // this.params.sort_by => 'created_at'\r\n\r\n      // the hash fragment is available on the hash property\r\n      // given a browser path of: '/posts/5?sort_by=created_at#someAnchorTag\r\n      // this.params.hash => 'someAnchorTag'\r\n    }\r\n  });\r\n});\r\n```\r\n\r\n## Client Side Routing\r\n\r\n### Rendering the Router\r\nBy default, the Router is rendered (appended) automatically to the document body\r\nwhen the DOM is ready. You can override this behavior and render the Router\r\nwhenever you'd like by setting a configuration option and using a Handlebars\r\nhelper like this:\r\n\r\n```javascript\r\nRouter.configure({\r\n  autoRender: false\r\n});\r\n```\r\n\r\n```html\r\n<body>\r\n  <div>\r\n    Some static content goes here\r\n  </div>\r\n\r\n  <div>\r\n    {{renderRouter}}\r\n  </div>\r\n</body>\r\n```\r\n\r\n### Path Functions and Helpers\r\nOnce your application becomes large enough, it becomes a pain to hard code urls\r\neverywhere. If you end up changing your route path a little, you need to find\r\nall of the href tags in your application and change those as well. It's much\r\nbetter if we can call a function to return a URL given a parameters object.\r\nThere are a few Handlebars helpers you can use directly in your HTML. You can\r\nalso call the `path` and `url` methods on a route itself. \r\n\r\nLet's say we have a route named \"postShow\" defined like this:\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('postShow', {\r\n    path: '/posts/:_id'\r\n  });\r\n});\r\n```\r\n\r\nYou can call the Route's path function to get a path for a given parameter\r\nobject. For example:\r\n\r\n```javascript\r\nRouter.routes['postShow'].path({_id: 1}) => '/posts/1'\r\n```\r\n\r\nYou can pass query params and a hash value as an option like this:\r\n\r\n```javascript\r\nRouter.routes['postShow'].path({_id: 1}, {\r\n  query: 'sort_by=created_at',\r\n  hash: 'someAnchorTag'\r\n});\r\n```\r\n\r\nThe query option can also be a regular JavaScript object. It will automatically\r\nbe turned into a query string. The above example would also work here:\r\n\r\n```javascript\r\nRouter.routes['postShow'].path({_id: 1}, {\r\n  query: {\r\n    sort_by: 'created_at'\r\n  },\r\n\r\n  hash: 'someAnchorTag'\r\n});\r\n```\r\n\r\nYou can get paths and urls for named routes directly in your html using a global\r\nHandlebars helper. The Handlebars helper uses the current data context as the\r\nfirst parameter to the `path` function shown above.\r\n\r\n```html\r\n<!-- given a context of {_id: 1} this will render '/posts/1' -->\r\n<a href=\"{{pathFor 'postShow'}}\">Post Show</a>\r\n```\r\n\r\nYou can change the data context before using the pathFor helper using the\r\nHandlebars `{{#with ...}}` helper like this:\r\n\r\n```html\r\n{{#with someOtherPost}}\r\n  <!-- someOtherPost now sets the data context -->\r\n  <!-- so say someOtherPost = { _id: 5 } then this renders '/posts/5' -->\r\n  <a href=\"{{pathFor 'postShow'}}\">Post Show</a>\r\n{{/with}}\r\n```\r\n\r\nYou can pass query params using the Handlebars helper like\r\nthis:\r\n\r\n```html\r\n<!-- given a context of {_id: 1} this will render '/posts/1?sort_by=created_at' -->\r\n<a href=\"{{pathFor 'postShow' query='sort_by=created_at'}}\">Post Show</a>\r\n```\r\nAnd you can pass a hash value using the Handlbars helper like this:\r\n\r\n```html\r\n<!-- given a context of {_id: 1} this will render '/posts/1?sort_by=created_at#someAnchorTag' -->\r\n<a href=\"{{pathFor 'postShow' query='sort_by=created_at' hash='someAnchorTag'}}\">Post Show</a>\r\n```\r\n\r\n### Changing routes programmatically\r\n\r\nSometimes you'll need to change the route without the user clicking a link. For this you can use `Router.go`:\r\n\r\n```javascript\r\n// you can pass a fully formed URL path in\r\nRouter.go('/posts/7');\r\n\r\n// but more likely, you'll want to use a route name and pass in arguments,\r\n// as you would in `pathFor`\r\nRouter.go('postShow', {_id: 7});\r\n```\r\n\r\nThe current route is returned reactively by `Router.current()`. It can be `null` (just like `Meteor.user()` can be null) so it's best to guard when working with reactive return values. For example, to find the current path:\r\n\r\n```javascript\r\nvar current = Router.current();\r\nreturn current && current.path;\r\n```\r\n\r\nInside a route controller (such as in a hook), you don't need to call `Router.current()` because `this` already points to the current route. For example, to track pages visited by users using the [analytics](https://atmospherejs.com/package/analyticsjs) package:\r\n\r\n```javascript\r\nRouter.configure({\r\n  ...\r\n  load: function () {\r\n    analytics.page(this.path);\r\n  }\r\n});\r\n```\r\n\r\n### Rendering Templates\r\nThe default action for a route is to render a template. You can specify a\r\ntemplate as an option to the route. If you don't provide a template, the route\r\nwill assume the template name is the same as the route name. For example:\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('home', {\r\n    path: '/'\r\n  });\r\n});\r\n```\r\nWhen you navigate to 'http://localhost:3000/' the above route will automatically\r\nrender the template named `home`.\r\n\r\nYou can change the template that is automatically rendered by providing a\r\ntemplate option.\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('home', {\r\n    path: '/',\r\n    template: 'myHomeTemplate'\r\n  });\r\n});\r\n```\r\n\r\nThe above example will map the `http://localhost:3000/` url (the `/` path) and\r\nautomatically render the template named `myHomeTemplate`.\r\n\r\n### Using a Layout with Yields\r\nOften times it's useful to have a layout template for a route. Then your route\r\ntemplate renders into the layout. You can actually render multiple templates\r\ninto the layout. You can specify a layout template by providing the\r\n`layoutTemplate` option to your route.\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('home', {\r\n    path: '/',\r\n    template: 'myHomeTemplate',\r\n    layoutTemplate: 'layout'\r\n  });\r\n});\r\n```\r\n\r\nThe layout template must declare where it wants various child templates to\r\nrender. You can do this by using the `{{> yield}}` helper. A basic layout would\r\nlook like this:\r\n\r\n```html\r\n<template name=\"layout\">\r\n  <div>\r\n    {{> yield}}\r\n  </div>\r\n</template>\r\n```\r\n\r\nBut you can also specify regions. This allows you to render templates\r\ninto any number of regions in the layout. For example:\r\n\r\n```html\r\n<template name=\"layout\">\r\n  <aside>\r\n    {{> yield region='aside'}}\r\n  </aside>\r\n\r\n  <div>\r\n    {{> yield}}\r\n  </div>\r\n\r\n  <footer>\r\n    {{> yield region='footer'}}\r\n  </footer>\r\n</template>\r\n```\r\n\r\nYou can specify which templates to render into the region using the\r\n`yieldTemplates` option of your route. For example:\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('home', {\r\n    path: '/',\r\n    template: 'myHomeTemplate',\r\n    layoutTemplate: 'layout',\r\n    yieldTemplates: {\r\n      'myAsideTemplate': {to: 'aside'},\r\n      'myFooter': {to: 'footer'}\r\n    }\r\n  });\r\n});\r\n```\r\n\r\nThe above example will render the template named `myAsideTemplate` to the region\r\nnamed `aside` and the template named `myFooter` to the region named `footer`. The\r\nmain template `myHomeTemplate` specified by the `template` option will be\r\nrendered into the **main** region. This is the region without a name\r\nin the center that looks like this: `{{> yield}}`.\r\n\r\n### Data\r\nYou can provide a data context for the current route by providing a `data`\r\noption to your route. The `data` value can either be an object or a function\r\nthat gets evaluated later (when your route is run). For example:\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('home', {\r\n    path: '/',\r\n    template: 'myHomeTemplate',\r\n    layoutTemplate: 'layout',\r\n    yieldTemplates: {\r\n      'myAsideTemplate': {to: 'aside'},\r\n      'myFooter': {to: 'footer'}\r\n    },\r\n\r\n    data: {\r\n      title: 'Some Title',\r\n      description: 'Some Description'\r\n    }\r\n  });\r\n});\r\n```\r\n\r\nGiven the above data context, our templates could use the data context like\r\nthis:\r\n\r\n```html\r\n<template name=\"myHomeTemplate\">\r\n  {{title}} - {{description}}\r\n</template>\r\n```\r\n\r\nThe data property can also be a function which is evaluated when the route is\r\nactually run.\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('home', {\r\n    path: '/',\r\n    template: 'myHomeTemplate',\r\n    layoutTemplate: 'layout',\r\n    yieldTemplates: {\r\n      'myAsideTemplate': {to: 'aside'},\r\n      'myFooter': {to: 'footer'}\r\n    },\r\n\r\n    data: function () {\r\n      // this.params is available inside the data function\r\n      var params = this.params;\r\n\r\n      return {\r\n        title: 'Some Title',\r\n        description: 'Some Description'\r\n      }\r\n    }\r\n  });\r\n});\r\n```\r\nYou can set the global data context of the Router by calling the `setData`\r\nfunction of the Router or a RouteController. The data context only invalidates\r\ncomputations if the data has actually changed from the last time it was set.\r\n\r\nYou can access the current data context using the `getData` function inside of\r\nany of your route functions (or RouteController functions). For example:\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('post', {\r\n    path: '/posts/:slug',\r\n\r\n    waitOn: function () {  // wait for the subscription to be ready; see below\r\n      return Meteor.subscribe('posts');\r\n    },\r\n\r\n    data: function () {\r\n      return Posts.findOne({slug: this.params.slug});\r\n    },\r\n\r\n    onBeforeAction: function () {\r\n      var post = this.getData();\r\n    }\r\n  });\r\n});\r\n```\r\n\r\nIf your data value or function returns null or undefined, the Router can\r\nautomatically render a not found template. This is useful if you want to render\r\na not found template for data that doesn't exist. You need to do two things - \r\n  1. Provide a `notFoundTemplate` option to your route.\r\n  2. Turn the `dataNotFound` hook on \r\n\r\n```javascript\r\nif (Meteor.isClient) {\r\n  Router.onBeforeAction('dataNotFound');\r\n}\r\n\r\nRouter.map(function () {\r\n  this.route('home', {\r\n    path: '/',\r\n    template: 'myHomeTemplate',\r\n    layoutTemplate: 'layout',\r\n    yieldTemplates: {\r\n      'myAsideTemplate': {to: 'aside'},\r\n      'myFooter': {to: 'footer'}\r\n    },\r\n\r\n    // render notFound template when data is null or undefined\r\n    notFoundTemplate: 'notFound', \r\n    data: function () {\r\n\r\n      // return Posts.findOne({_id: this.params._id});\r\n      // if the post isn't found then render the notFound template\r\n\r\n      // if data function returns null then notFound template is rendered.\r\n      return null;\r\n    }\r\n  });\r\n});\r\n```\r\n\r\nIf you provide a global `notFoundTemplate`, it will get rendered automatically if\r\na user visits an un-matched path, assuming it's not already handled on the server-side:\r\n\r\n```javascript\r\n// given a browser url of: http://localhost:3000/boguspath\r\n\r\nRouter.configure({\r\n  notFoundTemplate: 'notFound' // this will render\r\n});\r\n```\r\n\r\n### Waiting on Subscriptions (`waitOn`)\r\n\r\nSometimes it's useful to wait until you have data before rendering a page. For\r\nexample, let's say you want to show a not found template if the user navigates\r\nto a good url (say, `/posts/5`) but there is no post with an id of 5. You can't\r\nmake this determination until the data from the server has been sent.\r\n\r\nTo solve this problem, you can **wait** on a subscription, or anything with a\r\nreactive `ready()` method. To do this, you can provide a `waitOn` option to your\r\nroute like this:\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('postShow', {\r\n    path: '/posts/:_id',\r\n\r\n    waitOn: function () {\r\n      return Meteor.subscribe('posts');\r\n    }\r\n  });\r\n});\r\n```\r\n\r\nThe `waitOn` function can return any object that has a `ready` method. It can\r\nalso return an array of these objects if you'd like to wait on multiple\r\nsubscriptions.\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('postShow', {\r\n    path: '/posts/:slug',\r\n\r\n    waitOn: function () {\r\n      // NOTE: this.params is available inside the waitOn function.\r\n      var slug = this.params.slug;\r\n      return [Meteor.subscribe('posts'), Meteor.subscribe('comments', slug)];\r\n    }\r\n  });\r\n});\r\n```\r\n\r\nWhen your route is run, it will wait on any subscriptions you've provided in\r\nyour `waitOn` function. If you've provided a `loadingTemplate`, the default action \r\nwill be to render that template.\r\n\r\nWhile waiting, you can check if your subscriptions are ready in your `onBeforeAction`\r\nhooks, `action` method, and `onAfterAction` hooks, by checking `this.ready()`. \r\n\r\nUnder the hood, the waitOn function calls the `wait(handles, onReady,\r\nonWaiting)` method of a RouteController (more on RouteControllers below). If you\r\nneed to customize this behavior you can skip providing a `waitOn` property and\r\njust use the `wait` method directly in a custom action function or an `onBeforeAction`\r\nhook.\r\n\r\nYou can also wait for certain subscriptions on a global level, by passing a `waitOn`\r\nfunction in the `Router.configure()` call:\r\n\r\n```js\r\nRouter.configure({\r\n  waitOn: function () {\r\n    return Meteor.subscribe('recordSetThatYouNeedNoMatterWhat');\r\n  }\r\n});\r\n```\r\n\r\n\r\n### Waiting on Subscriptions (`wait()`)\r\n\r\n```js\r\nRouter.map(function () {\r\n  this.route('postShow', {\r\n    path: '/posts/:_id',\r\n    onBeforeAction: function() {\r\n      // wait on post\r\n      this.subscribe('post', this.params._id).wait(); // wait\r\n\r\n      // don't wait on posts\r\n      this.subscribe('posts');\r\n    }\r\n  });\r\n});\r\n```\r\n\r\nCalling `wait` on a subscription handle doesn't actually block anything. It just\r\nadds the subscription handle to a list of handles we are reactively waiting on.\r\nWhen all of these handles are ready `this.ready()` on the RouteController will\r\nbe true.\r\n\r\n```js\r\nRouter.map(function () {\r\n  this.route('postShow', {\r\n    path: '/posts/:_id',\r\n    \r\n    // this is equivalent to \r\n    // waitOn: function() { \r\n    //   return Meteor.subscribe('posts', this.params.:id); }\r\n    // }\r\n    \r\n    onBeforeAction: function() {\r\n      this.subscribe('posts', this.params._id).wait();\r\n    }\r\n  });\r\n});\r\n```\r\n\r\n### Using a Custom Action Function\r\nSo far, we haven't had to write much code to get our routes to work. We've just\r\nprovided configuration options to the route. Under the hood, when a route is\r\nrun, a RouteController gets created and an **action** method gets called on that\r\nRouteController. On the client, the default action function just renders the\r\nmain template and then all of the yield templates. We can provide our own\r\naction function like this:\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('postShow', {\r\n    path: '/posts/:_id',\r\n\r\n    action: function () {\r\n      // this => instance of RouteController\r\n      // access to:\r\n      //  this.params\r\n      //  this.wait\r\n      //  this.render\r\n      //  this.redirect\r\n    }\r\n  });\r\n});\r\n```\r\n\r\n### Custom Rendering\r\nYou can render manually by calling the `render` function. There are three ways\r\nto call the render method:\r\n\r\n  1. `this.render()`: Render all of the templates for the Route or\r\n     RouteController. This renders the main template into the main yield region,\r\n     and all of the yieldTemplates into their associated `{{> yield region='name'}}`\r\n     regions.\r\n  2. `this.render('templateName')`: Render the template named 'templateName'\r\n     into the main yield `{{> yield}}`.\r\n  3. `this.render('templateName', {to: 'region'})`: Render the template named\r\n     'templateName' into the region named 'region' `{{> yield region='region'}}`. \r\n\r\n*Note: layouts are at the route level, not the template level and you have one\r\nlayout per route or a globally defined layout.*\r\n\r\n### Using hooks\r\n\r\nThere are four types of hooks that a route provides. All can be added at the global level, in a route definition, or defined for a controller.\r\n\r\n- `onBeforeAction` - runs before the action function (possibly many times if reactivity is involved).\r\n- `onAfterAction` - runs after the action function (also reactively)\r\n- `load` - runs _just once_ when the route is first loaded. NOTE that this doesn't run again if your page reloads via hot-code-reload, so make sure any variables you set will persist over HCR (for example Session variables).\r\n- `unload` - runs _just once_ when you leave the route for a new route.\r\n\r\nYou can also define global hooks which apply to a set of named routes:\r\n\r\n```js\r\n// this hook will run on almost all routes\r\nRouter.onBeforeAction(mustBeSignedIn, {except: ['login', 'signup', 'forgotPassword']});\r\n\r\n// this hook will only run on certain routes\r\nRouter.onBeforeAction(mustBeAdmin, {only: ['adminDashboard', 'adminUsers', 'adminUsersEdit']});\r\n```\r\n\r\n### Before and After Hooks\r\nSometimes you want to execute some code *before* or *after* your action function\r\nis called. This is particularly useful for things like showing a login page\r\nanytime a user is not logged in. You can declare before and after hooks by\r\nproviding `onBeforeAction` and `onAfterAction` options to the route. The value can be a function\r\nor an array of functions which will be executed in the order they are defined.\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('postShow', {\r\n    path: '/posts/:_id',\r\n\r\n    onBeforeAction: function (pause) {\r\n      if (!Meteor.user()) {\r\n        // render the login template but keep the url in the browser the same\r\n        this.render('login');\r\n\r\n        // pause this rendering of the rest of the before hooks and the action function \r\n        pause();\r\n      }\r\n    },\r\n\r\n    action: function () {\r\n      // render the main template\r\n      this.render();\r\n\r\n      // combine render calls\r\n      this.render({\r\n        'myCustomFooter': { to: 'footer' },\r\n        'myCustomAside': { to: 'aside' }\r\n      });\r\n    },\r\n\r\n    onAfterAction: function () {\r\n      // this is run after our action function\r\n    }\r\n  });\r\n});\r\n```\r\n\r\nHooks and your action function are reactive by default. This means that if you\r\nuse a reactive data source inside of one of these functions, and that reactive\r\ndata source invalidates the computation, these functions will be run again.\r\n\r\n### Unload Hook\r\nUnload hooks will be called before a RouteController is unloaded and a new\r\nRouteController is run. This hook is useful for cleaning up Session data for\r\nexample.\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('postShow', {\r\n    path: '/login',\r\n\r\n    unload: function () {\r\n      // This is called when you navigate to a new route\r\n      Session.set('postId', null);\r\n    }\r\n  });\r\n});\r\n```\r\n\r\n### Global Router Configuration\r\nSo far we've been defining all of our route options on the routes themselves.\r\nBut sometimes it makes sense to define global options that apply to all routes.\r\nThis is most often used for the `layoutTemplate`, `notFoundTemplate`, and\r\n`loadingTemplate` options. You can globally configure the Router like this:\r\n\r\n```javascript\r\nRouter.configure({\r\n  layoutTemplate: 'layout',\r\n  notFoundTemplate: 'notFound',\r\n  loadingTemplate: 'loading'\r\n});\r\n```\r\n\r\n## Server Side Routing\r\nDefining routes and configuring the Router is almost identical on the server and\r\nthe client. By default, routes are created as client routes. You can specify\r\nthat a route is intended for the server by providing a `where` property to the\r\nroute like this:\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('serverRoute', {\r\n    where: 'server',\r\n\r\n    action: function () {\r\n      // some special server side properties are available here\r\n    }\r\n  });\r\n});\r\n```\r\n\r\nNote that `where` must be placed in `Router.map`, not on the controller.\r\n\r\nServer action functions (RouteControllers) have different properties and methods\r\navailable. Namely, there is no rendering on the server yet. So the `render`\r\nmethod is not available. Also, you cannot `waitOn` subscriptions or call the\r\n`wait` method on the server. Server routes get the bare `request`, `response`,\r\nand `next` properties of the Connect request, as well as the params object just\r\nlike in the client.\r\n\r\n```javascript\r\nRouter.map(function () {\r\n  this.route('serverFile', {\r\n    where: 'server',\r\n    path: '/files/:filename',\r\n\r\n    action: function () {\r\n      var filename = this.params.filename;\r\n\r\n      this.response.writeHead(200, {'Content-Type': 'text/html'});\r\n      this.response.end('hello from server');\r\n    }\r\n  });\r\n});\r\n```\r\n\r\n## Route Controllers\r\nMost of the time, you can define how you want your routes to behave by simply\r\nproviding configuration options to the route. But as your application gets\r\nlarger, you may want to separate the logic for handling a particular route into\r\na separate class. This is useful for putting route handling logic into separate\r\nfiles, but also for utilizing features like inheritance. You can do this by\r\ninheriting from `RouteController`. This works on both the client and the server,\r\nbut each has slightly different methods as described above.\r\n\r\nAlthough we haven't been working with `RouteController`s directly, under the\r\nhood they were getting created automatically for us when our routes were run.\r\nThese are called \"anonymous\" `RouteController`s. But we can create our own like\r\nthis:\r\n\r\n```javascript\r\nPostShowController = RouteController.extend({\r\n  /* most of the options we've been using in our routes can be used here */\r\n});\r\n```\r\n\r\nHow does a route know about our custom RouteController? Let's say we have a\r\nroute named \"postShow\". When the route is run, it will look for a global object\r\nnamed \"PostShowController\", after the name of the route. We can change this\r\nbehavior by providing a `controller` option to the route like so:\r\n\r\n```javascript\r\nRouter.map(function () {\r\n\r\n  // provide a String to evaluate later\r\n  this.route('postShow', {\r\n    controller: 'CustomController'\r\n  });\r\n\r\n  // provide the actual controller symbol if it's already defined\r\n  this.route('postShow', {\r\n    controller: CustomController\r\n  });\r\n});\r\n```\r\n\r\nWe can define almost all of the same options on our RouteController as we have\r\nfor our routes. For example:\r\n\r\n```javascript\r\nPostShowController = RouteController.extend({\r\n  template: 'postShow',\r\n\r\n  layoutTemplate: 'postLayout',\r\n\r\n  onBeforeAction: function () {\r\n  },\r\n\r\n  onAfterAction: function () {\r\n  },\r\n\r\n  waitOn: function () {\r\n    return Meteor.subscribe('post', this.params._id);\r\n  },\r\n\r\n  data: function () {\r\n    return Posts.findOne({_id: this.params._id});\r\n  },\r\n\r\n  action: function () {\r\n    /* if we want to override default behavior */\r\n  }\r\n});\r\n```\r\n\r\nNote that `onBeforeAction` and `onAfterAction` are class level methods of our new\r\ncontroller. We can pass them as properties to the `extend` method for convenience.\r\nBut we can also do this:\r\n\r\n```javascript\r\nPostShowController.onBeforeAction(function () {});\r\nPostShowController.onAfterAction(function () {});\r\n```\r\n\r\n(But note `where` is not available on controllers, only in `Router.map`.)\r\n\r\nIn Coffeescript we can use the language's native inheritance.\r\n\r\n```coffeescript\r\nclass @PostShowController extends RouteController\r\n  onBeforeAction: ->\r\n    # do some stuff before the action is invoked\r\n\r\n  onAfterAction: ->\r\n    # do some stuff after the action is invoked\r\n\r\n  layout: 'layout'\r\n\r\n  template: 'myTemplate'\r\n```\r\n\r\n## Examples\r\n\r\n### Parsing Url Parameters (OAuth Example)  \r\n\r\nIron Router will automatically parse a parameterized URL request, and separate out the parameters into an object.  However, accessing those parameters requires extending a RouteController.  Consider the following scenario:\r\n\r\n````ruby\r\n# OAuth Configuration Scenario\r\n\r\n# OAuth requires a redirect URL as part of it's configuration.\r\nhttp://localhost:3600/stripe\r\n\r\n# the oauth authentication process will redirect users to that URL with parameterized tokens\r\nhttp://localhost:3600/stripe?scope=read_only&code=ac_2QGZP0nOBmb0Lxk9q3pMzaRvOi4fMU8j\r\n\r\n# so the Router needs to parse the following line of code\r\n?scope=read_only&code=ac_2QGZP0nOBmb0Lxk9q3pMzaRvOi4fMU8j\r\n\r\n# in order to obtain the following parameters\r\nscope = read_only\r\ncode = ac_2QGZP0nOBmb0Lxk9q3pMzaRvOi4fMU8j\r\n\r\n````\r\n\r\nTo parse the ``scope`` and ``code`` parameters correctly, we need to set up something like the following:\r\n\r\n````js\r\n//---------------------------------------------------------------------------------------------------------------------\r\n// Iron Router Configuration\r\n\r\nSession.setDefault('oauth_scope', '');\r\nSession.setDefault('oauth_code', '');\r\n\r\n// create the route like normal; the parameters will be automatically parsed\r\nRouter.map(function() {\r\n    this.route('stripeRedirect', { path: '/stripe'});\r\n});\r\n\r\n// and extend the controller, so you can access the this.params object\r\nStripeRedirectController = RouteController.extend({\r\n    run: function () {\r\n        // the code parameter has been automatically parsed and is available for use\r\n        console.log('stripe.code: ' + this.params.code);\r\n        Session.set('oauth_code', this.params.code);\r\n\r\n        // as is the scope parameter\r\n        console.log('stripe.scope: ' + this.params.scope);\r\n        Session.set('oauth_scope', this.params.scope);\r\n\r\n        // when all this is done, be sure to render the template specified in the router map\r\n        this.render('stripeRedirect');\r\n    }\r\n});\r\n````\r\n\r\nOnce you have access to the parameters, there are numerous ways to pass those variables throughout your app.  `Session.set()` is just one method.  You'll need to choose whether you want to use reactive `Session` variables or not.  \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}