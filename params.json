{"name":"Iron-router","tagline":"Routing designed specifically for Meteor.","body":"# Iron Router \r\n\r\nA client and server side router designed specifically for Meteor.\r\n\r\n\r\n## History\r\n\r\n**Latest Version:** 0.7.2\r\n\r\nSee the [History.md](History.md) file for changes (including breaking changes) across\r\nversions.\r\n\r\n## About\r\n\r\nIron Router is a *routing* package for Meteor. It makes single page apps.\r\n\r\nIR takes control of your `<body>` tag, rendering templates based on the user's current URL. It also helps you set up subscriptions per-route and much more.\r\n\r\nIron Router works with Meteor 0.8.0 and above. To use an earlier version, use a version of IR less than 0.7.0.\r\n\r\n##  Installation\r\n\r\nIron Router can be installed with [Meteorite](https://github.com/oortcloud/meteorite/). From inside a Meteorite-managed app:\r\n\r\n``` sh\r\n$ mrt add iron-router\r\n```\r\n\r\n## API\r\nMore detailed documentation can be found [here](DOCS.md).\r\n\r\n### Basics\r\n\r\n#### Declaring a route\r\n\r\nYou place your route declarations in a `Router.map` block: \r\n\r\n```javascript\r\nRouter.map(function() {\r\n  this.route('home', {path: '/'});\r\n  this.route('about');\r\n});\r\n```\r\n\r\nThe first route is named `home`, and will render a template named `home` at the path `/`. The second is named `about`, and will render a template named `about` at the path `/about`.\r\n\r\nYou should define your routes in a file common to the client and server so both contexts can use them.\r\n\r\n#### Using routes\r\n\r\nTo use a route in your app, you can use the `{{pathFor}}` handlebars helper:\r\n\r\n```html\r\n<a href=\"{{pathFor 'home'}}\">Go home!</a>\r\n```\r\n\r\nOr, call `Router.path('home')` to get it as a string.\r\n\r\nThe router will pick up internal clicks on links to routes. \r\nAlternatively, you can directly call `Router.go()` in a event handler:\r\n\r\n```javascript\r\nTemplate.foo.events({\r\n 'click .homeLink': function() {\r\n    Router.go('home');\r\n  }\r\n});\r\n```\r\n\r\n#### Parameterized routes and data\r\n\r\nAs your application starts dealing with data, you'll probably want to write more than a few static routes.\r\n\r\nA standard pattern is a route per object in a collection. You can achieve this with a parameterized route:\r\n\r\n```javascript\r\nthis.route('postsShow', { \r\n  path: '/posts/:_id',\r\n  data: function() { return Posts.findOne(this.params._id); }\r\n});\r\n```\r\n\r\nThis route will match *any* URL of the form `'/posts/X'`, making the value of `X` available on the `this.params._id` property of the matching *controller*.\r\n\r\n`this` is an instance of a `RouteController` in the data function above. The value returned from the data function can be used in our templates.\r\n\r\nSo our template might look like (if posts have a `title` field):\r\n\r\n```html\r\n<template name=\"postsShow\">\r\n  <h1>{{title}}</h1>\r\n</template>\r\n```\r\n\r\n\r\n#### Controlling subscriptions\r\n\r\nThe example above assumes that you've already loaded the relevant post into your application, but usually you want to load data on demand as you hit a route. To do this, we can expand the example to use `waitOn`:\r\n\r\n```javascript\r\nthis.route('postsShow', { \r\n  path: '/posts/:_id',\r\n  waitOn: function() { return Meteor.subscribe('post', this.params._id)},\r\n  data: function() { return Posts.findOne(this.params._id); }\r\n});\r\n```\r\n\r\nReturning a subscription handle, or anything with a `ready` method from the `waitOn` function will add the handle to a wait list. When you call `this.ready()` in any of your other route functions, the result is true if all items in the wait list are ready. This lets us do things like show a loading indicator while waiting for data. You can implement a loading indicator in your route like this:\r\n\r\n```javascript\r\nthis.route('postsShow', {\r\n  waitOn: function () {\r\n    return Meteor.subscribe('post', this.params._id);\r\n  },\r\n\r\n  action: function () {\r\n    if (this.ready())\r\n      this.render();\r\n    else\r\n      this.render('loading');\r\n  }\r\n});\r\n```\r\n\r\nBut instead of writing this code yourself, you can use the 'loading' hook that comes with Iron Router like this:\r\n\r\n```javascript\r\nRouter.onBeforeAction('loading');\r\n```\r\n\r\n### Advanced\r\n\r\n#### Layouts + rendering\r\n\r\nBy default, the router renders the current template directly into the body. If you'd like to share common HTML between routes, you can create your own layout:\r\n\r\n```html\r\n<template name=\"masterLayout\">\r\n  <nav>...</nav>\r\n  <div id=\"content\">\r\n    {{> yield}}\r\n  </div>\r\n</template>\r\n```\r\n\r\nYou can set the layout via the `layoutTemplate` option to a route or in `Router.configure({...})`.\r\n\r\nLayouts are very flexible. You can read more about them [in the docs](DOCS.md#using-a-layout-with-yields).\r\n\r\n#### Route options\r\n\r\nThere are some extra routing options of interest:\r\n\r\n - `template` - the template to render. We've seen that by default this is just the name of the route.\r\n- `layoutTemplate` - the layout template to render.\r\n - `loadingTemplate` - the template used by the `loading` hook.\r\n - `notFoundTemplate` - the template used by the `dataNotFound` hook -- renders if the `data()` function returns something falsey.\r\n - `where` - whether this route runs on the client or the server\r\n\r\nWhere it makes sense, options can be set globally via `Router.configure()`.\r\n\r\n#### Custom actions and hooks\r\n\r\nYou can hook into the route run cycle via the following hooks:\r\n\r\n - `onRun` - this happens *once only* when the route is loaded. \r\n \r\n   NOTE: if the page hot code reloads, the onRun hook *will not re-run*. This makes it appropriate for things like analytics, or setting session variables and not for on-page setup.\r\n - `onData` - runs reactively whenever the data changes.\r\n - `onBeforeAction` - runs reactively before the action.\r\n - `onAfterAction` - likewise, after the action.\r\n - `onStop` - runs once when the controller is stopped, like just before a user routes away.\r\n\r\nYou can also change the action of a route via the `action` option. By default, the controller calls `this.render()`, which renders the relevant templates to the layout. You can call it yourself in an action function -- but if you are doing that you are probably better served using a `onBeforeAction` or `onAfterAction` hook.\r\n\r\nAll hooks (and `waitOn`) can be set globally to the router via (for example):\r\n\r\n```javascript\r\nRouter.onRun(function() {\r\n  console.log('Reached non-home page!');\r\n}, {except: 'home'});\r\n```\r\n\r\nThe second argument can be `except` -- a list of routes to not apply to, or `only` -- a limited set of routes to match.\r\n\r\n#### Server routing\r\n\r\nMost of the above only applies to client routes (we can't render templates on the server right now). \r\n\r\nWhen you define a server route (via `where: 'server'`), you need to define the `action` function, and use in a fairly simplistic way, much like [express](http://expressjs.com):\r\n\r\n```javascript\r\nthis.route('serverRoute', {\r\n  where: 'server',\r\n  action: function() {\r\n    this.response.end(\"THIS IS A SERVER ROUTE..\");\r\n  }\r\n})\r\n```\r\n\r\n[Read more about server routes](DOCS.md#server-side-routing).\r\n\r\n#### Route Controllers\r\n\r\nWe've mentioned that `this` in route callbacks is a *Route Controller*. Explicitly defining controllers allows you to use inheritance:\r\n\r\n```javascript\r\nAdminController = RouteController.extend({\r\n  onBeforeAction: // a user filter to control access?\r\n});\r\n\r\nPostsEditController = AdminController.extend({\r\n  waitOn: function() { return Meteor.subscribe('adminPost', ...); }\r\n});\r\n\r\nRouter.map(function() {\r\n  // this will automatically match the `PostsEditController` thanks to the name.\r\n  this.route(postsEdit, {path: '/posts/:_id/edit'});\r\n});\r\n```\r\n\r\n[Read more about route controllers](DOCS.md#route-controllers).\r\n\r\n\r\n### More\r\n\r\nFor full details see the [Docs](DOCS.md)\r\n\r\n## Contributing\r\n\r\nContributors are very welcome. There are many things you can help with,\r\nincluding finding and fixing bugs, creating examples for the examples folder,\r\ncontributing to improved design or adding features. Some guidelines below:\r\n\r\n* **Questions**: Please post to Stack Overflow and tag with `iron-router` : http://stackoverflow.com/questions/tagged/iron-router.\r\n\r\n* **New Features**: If you'd like to work on a feature for the iron-router,\r\n  start by creating a 'Feature Design: Title' issue. This will let people bat it\r\n  around a bit before you send a full blown pull request. Also, you can create\r\n  an issue to discuss a design even if you won't be working on it. Any\r\n  collaboration is good! But please be patient :-).\r\n\r\n* **Bugs**: If you find a bug and it's non-obvious what's causing it (almost\r\n  always) please provide a reproduction Github project and give some context\r\n  around the bug. Pasting in a snippet of JavaScript probably won't be enough.\r\n\r\n* **Answer Questions!**: If you can help another user please do!\r\n\r\nHow to create a reproduction:\r\nhttps://www.eventedmind.com/feed/github-issues-and-reproductions\r\n\r\n#### Local installation\r\n\r\n  This is useful if you're working off of the dev branch or contributing.\r\n\r\n  1. Set up a local packages folder\r\n  2. Add the PACKAGE_DIRS environment variable to your .bashrc file\r\n    - Example: `export PACKAGE_DIRS=\"/Users/cmather/code/packages\"`\r\n    - Screencast: https://www.eventedmind.com/posts/meteor-versioning-and-packages\r\n  3. Clone the repository into your local packages directory\r\n  4. Add iron-router just like any other meteor core package like this: `meteor\r\n     add iron-router`\r\n\r\n  ```sh\r\n  $ git clone https://github.com/EventedMind/iron-router.git /Users/cmather/code/packages\r\n  $ cd my-project\r\n  $ meteor add iron-router\r\n  ```\r\n\r\n## License\r\n\r\nMIT\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}