{"name":"Iron.Router","tagline":"A router that works on the server and the browser, designed specifically for Meteor.","body":"# Iron.Router\r\n\r\nA router that works on the server and the browser, designed specifically for\r\n[Meteor](https://github.com/meteor/meteor).\r\n\r\n## Quick Start\r\nYou can install iron:router using Meteor's package management system:\r\n\r\n```bash\r\n> meteor add iron:router\r\n```\r\n\r\nTo update iron:router to the latest version you can use the meteor update\r\ncommand:\r\n\r\n```bash\r\n> meteor update iron:router\r\n```\r\n\r\nStart by creating a route in your JavaScript file. By default, routes are\r\ncreated for the client and will run in the browser.\r\n\r\n```javascript\r\nRouter.route('/', function () {\r\n  this.render('Home');\r\n});\r\n```\r\n\r\nWhen the user navigates to the url \"/\", the route above will render the template\r\nnamed \"Home\" onto the page.\r\n\r\n```javascript\r\nRouter.route('/items');\r\n```\r\n\r\nThis second route will automatically render a template named \"Items\" or \"items\"\r\nto the page. In simple cases like this, you don't even need to provide a route\r\nfunction.\r\n\r\nSo far, we've only created routes that will be run directly in the browser. But\r\nwe can also create server routes. \r\n\r\n```javascript\r\nRouter.route('/item', function () {\r\n  var req = this.request;\r\n  var res = this.response;\r\n  res.end('hello from the server\\n');\r\n}, {where: 'server'});\r\n```\r\n\r\nThe `where: 'server'` option tells the Router this is a server side route.\r\n\r\n## Table of Contents\r\n\r\n- [Concepts](#concepts)\r\n  - [Server Only](#server-only)\r\n  - [Client Only](#client-only)\r\n  - [Client and Server](#client-and-server)\r\n  - [Reactivity](#reactivity)\r\n- [Route Parameters](#route-parameters)\r\n- [Rendering Templates](#rendering-templates)\r\n- [Rendering Templates with Data](#rendering-templates-with-data)\r\n- [Layouts](#layouts)\r\n  - [Rendering Templates into Regions with JavaScript](#rendering-templates-into-regions-with-javascript)\r\n  - [Setting Region Data Contexts](#setting-region-data-contexts)\r\n  - [Rendering Templates into Regions using contentFor](#rendering-templates-into-regions-using-contentfor)\r\n- [Client Navigation](#client-navigation)\r\n  - [Using Links](#using-links)\r\n  - [Using JavaScript](#using-javascript)\r\n  - [Using Redirects](#using-redirects)\r\n  - [Using Links to Server Routes](#using-links-to-server-routes)\r\n- [Named Routes](#named-routes)\r\n- [Path and Link Template Helpers](#path-and-link-template-helpers)\r\n  - [pathFor](#pathfor)\r\n  - [urlFor](#urlFor)\r\n  - [linkTo](#linkTo)\r\n- [Route Options](#route-options)\r\n  - [Route Specific Options](#route-specific-options)\r\n  - [Global Default Options](#global-default-options)\r\n- [Waiting on Subscriptions](#waiting-on-subscriptions)\r\n  - [Wait and Ready](#wait-and-ready)\r\n  - [Using waitOn](#using-waiton)\r\n- [Server Routing](#server-routing)\r\n  - [Creating Routes](#creating-routes)\r\n  - [Restful Routes](#restful-routes)\r\n  - [404s and Client vs Server Routes](#404s-and-client-vs-server-routes)\r\n  - [Server Middleware and Connect](#server-middleware-and-connect)\r\n- [Plugins](#plugins)\r\n  - [Creating Plugins](#creating-plugins)\r\n- [Hooks](#hooks)\r\n  - [Using Hooks](#using-hooks)\r\n  - [Applying Hooks to Specific Routes](#applying-hooks-to-specific-routes)\r\n  - [Using the Iron.Router.hooks Namespace](#using-the-iron-router-hooks-namespace)\r\n  - [Available Hook Methods](#available-hook-methods)\r\n- [Route Controllers](#route-controllers)\r\n  - [Creating Route Controllers](#creating-route-controllers) \r\n  - [Inheriting from Route Controllers](#inheriting-from-route-controllers) \r\n  - [Accessing the Current Route Controller](#accessing-the-current-route-controller)\r\n  - [Setting Reactive State Variables](#setting-reactive-state-variables)\r\n  - [Getting Reactive State Variables](#getting-reactive-state-variables)\r\n- [Custom Router Rendering](#custom-router-rendering)\r\n- [Legacy Browser Support](#legacy-browser-support)\r\n\r\n## Concepts\r\n\r\n### Server Only\r\nIn a typical Web app, you make an http request to a server at a particular url,\r\nlike \"/items/5\", and a router on the server decides which function to invoke for\r\nthat particular route. The function will most likely send some html back to the\r\nbrowser and close the connection.\r\n\r\n### Client Only\r\nIn some more modern Web apps you'll use a \"client side\" router like pagejs or\r\nBackbone router. These routers run in the browser, and let you navigate around\r\nan application without making trips to the server by taking advantage of browser\r\nHTML5 features like pushState or url hash fragments. \r\n\r\n### Client and Server\r\nIron.Router runs on the client *and* the server. You can define a route that\r\nonly should run on the server, or a route that should only run on the client.\r\nMost of the time you'll create routes on the client. This makes your app really\r\nfast once it's loaded, because as you navigate around the application, you don't\r\nneed to load an entirely new html page.\r\n\r\nThe router is *aware* of all the routes on the client and the server. This means\r\nyou can click a link that takes you to a server route, or it might take you to a\r\nclient route. It also means that on the server, if there is no client route\r\ndefined, we can send a 404 response to the client instead of loading up the\r\nMeteor application.\r\n\r\n### Reactivity\r\nYour route functions and most hooks are run in a reactive computation. This\r\nmeans they will rerun automatically if a reactive data source changes. For\r\nexample, if you call `Meteor.user()` inside of your route function, your route\r\nfunction will rerun each time the value of `Meteor.user()` changes.\r\n\r\n## Route Parameters\r\n\r\nRoutes can have variable parameters. For example, you can create one route to\r\nshow any post with an id. The `id` is variable depending on the post you want to\r\nsee such as \"/posts/1\" or \"/posts/2\". To declare a named parameter in your route\r\nuse the `:` syntax in the url followed by the parameter name. When a user goes\r\nto that url, the actual value of the parameter will be stored as a property on\r\n`this.params` in your route function.\r\n\r\nIn this example we have a route parameter named `_id`. If we navigate to the\r\n`/post/5` url in our browser, inside of the route function we can get the actual\r\nvalue of the `_id` from `this.params._id`. In this case `this.params._id => 5`.\r\n\r\n```javascript\r\n// given a url like \"/post/5\"\r\nRouter.route('/post/:_id', function () {\r\n  var params = this.params; // { _id: \"5\" }\r\n  var id = params._id; // \"5\"\r\n});\r\n```\r\n\r\nYou can have multiple route parameters. In this example, we have an `_id`\r\nparameter and a `commentId` parameter. If you navigate to the url\r\n`/post/5/comments/100` then inside your route function `this.params._id => 5`\r\nand `this.params.commentId => 100`.\r\n\r\n```javascript\r\n// given a url like \"/post/5/comments/100\"\r\nRouter.route('/post/:_id/comments/:commentId', function () {\r\n  var id = this.params.id; // \"5\"\r\n  var commentId = this.params.commentId; // \"100\"\r\n});\r\n```\r\n\r\nIf there is a query string or hash fragment in the url, you can access those\r\nusing the `query` and `hash` properties of the `this.params` object.\r\n\r\n```javascript\r\n// given the url: \"/post/5?q=s#hashFrag\"\r\nRouter.route('/post/:_id', function () {\r\n  var id = this.params._id;\r\n  var query = this.params.query;\r\n  \r\n  // query.q -> \"s\"\r\n  var hash = this.params.hash; // \"hashFrag\"\r\n});\r\n```\r\n\r\n## Rendering Templates\r\nUsually we want to render a template when the user goes to a particular url. For\r\nexample, we might want to render the template named `Post` when the user\r\nnavigates to the url `/posts/1`.\r\n\r\n```html\r\n<template name=\"Post\">\r\n  <h1>Post: {{title}}</h1>\r\n</template>\r\n```\r\n\r\n```javascript\r\nRouter.route('/post/:_id', function () {\r\n  this.render('Post');\r\n});\r\n```\r\n\r\nWe can render a template by calling the `render` method inside of our route\r\nfunction. The `render` method takes the name of a template as its first\r\nparameter.\r\n\r\n## Rendering Templates with Data\r\nIn the above example the `title` value is not defined. We could create a helper\r\non the Post template called `title` or we can set a data context for the\r\ntemplate directly from our route function. To do that, we provide a `data`\r\noption as a second parameter to the `render` call.\r\n\r\n```javascript\r\nRouter.route('/post/:_id', function () {\r\n  this.render('Post', {\r\n    data: function () {\r\n      return Posts.findOne({_id: this.params._id});\r\n    }\r\n  });\r\n});\r\n```\r\n\r\n## Layouts\r\nLayouts allow you to reuse a common look and feel in multiple pages in your\r\napplication so you don't have to duplicate the html and logic on every single\r\npage template.\r\n\r\nLayouts are just templates. But, inside of a layout you can use a special helper\r\ncalled `yield`. You can think of `yield` as a placeholder for content. The\r\nplaceholder is called a *region.* The content will be \"injected\" into the\r\nregion when we actually run our route.  This lets us reuse the layout on many\r\ndifferent pages, only changing the content of the *yield regions*.\r\n\r\n```html\r\n<template name=\"ApplicationLayout\">\r\n  <header>\r\n    <h1>{{title}}</h1>\r\n  </header>\r\n\r\n  <aside>\r\n    {{> yield \"aside\"}}\r\n  </aside>\r\n\r\n  <article>\r\n    {{> yield}}\r\n  </article>\r\n\r\n  <footer>\r\n    {{> yield \"footer\"}}\r\n  </footer>\r\n</template>\r\n```\r\n\r\nWe can tell our route function which layout template to use by calling the\r\n`layout` method.\r\n\r\n```javascript\r\nRouter.route('/post/:_id', function () {\r\n  this.layout('ApplicationLayout');\r\n});\r\n```\r\n\r\nIf you want to use a default layout template for all routes you can configure a\r\nglobal Router option.\r\n\r\n```javascript\r\nRouter.configure({\r\n  layoutTemplate: 'ApplicationLayout'\r\n});\r\n```\r\n\r\n### Rendering Templates into Regions with JavaScript\r\nInside of our route function we can tell the router which templates to render\r\ninto each region. \r\n\r\n```html\r\n<template name=\"Post\">\r\n  <p>\r\n    {{post_content}}\r\n  </p>\r\n</template>\r\n\r\n<template name=\"PostFooter\">\r\n  Some post specific footer content.\r\n</template>\r\n\r\n<template name=\"PostAside\">\r\n  Some post specific aside content.\r\n</template>\r\n```\r\nLet's say we're using the `ApplicationLayout` and we want to put the templates\r\ndefined above into their respective regions for the `/post/:_id` route. We can\r\ndo this directly in our route function using the `to` option of the `render`\r\nmethod.\r\n\r\n```javascript\r\nRouter.route('/post/:_id', function () {\r\n  // use the template named ApplicationLayout for our layout\r\n  this.layout('ApplicationLayout');\r\n\r\n  // render the Post template into the \"main\" region\r\n  // {{> yield}}\r\n  this.render('Post');\r\n\r\n  // render the PostAside template into the yield region named \"aside\" \r\n  // {{> yield \"aside\"}}\r\n  this.render('PostAside', {to: 'aside'});\r\n\r\n  // render the PostFooter template into the yield region named \"footer\" \r\n  // {{> yield \"footer\"}}\r\n  this.render('PostFooter', {to: 'footer'});\r\n});\r\n```\r\n\r\n### Setting Region Data Contexts\r\nYou can set the data contexts for regions by providing a `data` option to the\r\n`render` method. You can also set a data context for the entire layout.\r\n\r\n```javascript\r\nRouter.route('/post/:_id', function () {\r\n  this.layout('ApplicationLayout', {\r\n    data: function () { return Posts.findOne({_id: this.params._id}) }\r\n  });\r\n\r\n  this.render('Post' {\r\n    // we don't really need this since we set the data context for the\r\n    // the entire layout above. But this demonstrates how you can set\r\n    // a new data context for each specific region.\r\n    data: function () { return Posts.findOne({_id: this.params._id})\r\n  });\r\n\r\n  this.render('PostAside', {\r\n    to: 'aside',\r\n    data: function () { return Posts.findOne({_id: this.params._id})\r\n  });\r\n\r\n  this.render('PostFooter', {\r\n    to: 'footer',\r\n    data: function () { return Posts.findOne({_id: this.params._id})\r\n  });\r\n});\r\n```\r\n\r\n### Rendering Templates into Regions using contentFor\r\nRendering templates into region from our route function can be useful,\r\nespecially if we need to run some custom logic or if the template names are\r\ndynamic. But often an easier way to provide content for a region is to use the\r\n`contentFor` helper directly from our main template. Let's say we're using the\r\nsame `ApplicationLayout` from the previous example. But this time, instead of\r\ndefining a new template for each region, we'll provide the content *inline* in\r\nour `Post` template.\r\n\r\n```html\r\n<template name=\"Post\">\r\n  <p>\r\n    {{post_content}}\r\n  </p>\r\n\r\n  {{#contentFor \"aside\"}}\r\n    Some post specific aside content.\r\n  {{/contentFor}}\r\n\r\n  {{#contentFor \"footer\"}}\r\n    Some post specific footer content.\r\n  {{/contentFor}}\r\n</template>\r\n```\r\n\r\nNow we can simply specify our layout and render the `Post` template instead of\r\neach individual region.\r\n\r\n```javascript\r\nRouter.route('/post/:_id', function () {\r\n  this.layout('ApplicationLayout', {\r\n    data: function () { return Posts.findOne({_id: this.params._id}) }\r\n  });\r\n\r\n  // this time just render the template named \"Post\" into the main\r\n  // region\r\n  this.render('Post');\r\n});\r\n```\r\n\r\nYou can even provide a template option to the `contentFor` helper instead of\r\nproviding in-line block content.\r\n\r\n```html\r\n<template name=\"Post\">\r\n  <p>\r\n    {{post_content}}\r\n  </p>\r\n\r\n  {{> contentFor region=\"aside\" template=\"PostAside\"}}\r\n\r\n  {{> contentFor region=\"footer\" template=\"PostFooter\"}}\r\n</template>\r\n```\r\n\r\n## Client Navigation\r\nMost of the time users of your application will navigate around the app inside\r\nthe browser instead of making new requests to the server for each page. There\r\nare a few ways to navigate around the application.\r\n\r\n### Using Links\r\nUsers can navigate around the application by clicking links. Let's say we have a\r\nlayout with some navigation links.\r\n\r\n```html\r\n<template name=\"ApplicationLayout\">\r\n  <nav>\r\n    <ul>\r\n      <li>\r\n        <a href=\"/\">Home</a>\r\n      </li>\r\n      \r\n      <li>\r\n        <a href=\"/one\">Page One</a>\r\n      </li>\r\n\r\n      <li>\r\n        <a href=\"/two\">Page Two</a>\r\n      </li>\r\n    </ul>\r\n  </nav>\r\n\r\n  <article>\r\n    {{> yield}}\r\n  </article>\r\n</template>\r\n\r\n<template name=\"Home\">\r\n  Home\r\n</template>\r\n\r\n<template name=\"PageOne\">\r\n  Page One\r\n</template>\r\n\r\n<template name=\"PageTwo\">\r\n  Page Two\r\n</template>\r\n```\r\n\r\nNext, we'll define some routes for these pages.\r\n\r\n```javascript\r\nRouter.route('/', function () {\r\n  this.render('Home');\r\n});\r\n\r\nRouter.route('/one', function () {\r\n  this.render('PageOne');\r\n});\r\n\r\nRouter.route('/two', function () {\r\n  this.render('PageTwo');\r\n});\r\n```\r\nWhen the application first loads at the root url `/` the first route will run\r\nand the template named \"Home\" will be rendered to the page.\r\n\r\nIf the user clicks the `Page One` link, the url in the browser will change to\r\n'/one' and the second route will run, rendering the 'PageOne' template.\r\n\r\nLikewise, if the user clicks the `Page Two` link, the url in the browser will\r\nchange to '/two' and the third route will run, rendering the 'PageTwo' template.\r\n\r\nEven though the url is changing in the browser, since these are client-side\r\nroutes, the browser doesn't need to make requests to the server. \r\n\r\n### Using JavaScript\r\nYou can navigate to a given url, or even a route name, from JavaScript using the\r\n`Router.go` method. Let's say we've defined a click event handler for a button.\r\n\r\n```html\r\n<template name=\"MyButton\">\r\n  <button id=\"clickme\">Go to Page One</button>\r\n</template>\r\n```\r\n\r\nIn our click event handler we can tell the router to go to the `/one` url.\r\n\r\n```javascript\r\nTemplate.MyButton.events({\r\n  'click #clickme': function () {\r\n    Router.go('/one');\r\n  }\r\n});\r\n```\r\n\r\nThis will change the browser's url to `/one` and run the corresponding route.\r\n\r\n### Using Redirects\r\nYou can redirect from one route to another from inside a route function by using\r\nthe `redirect` method inside your route function.\r\n\r\n```javascript\r\nRouter.route('/one', function () {\r\n  this.redirect('/two');\r\n});\r\n\r\nRouter.route('/two', function () {\r\n  this.render('PageTwo');\r\n});\r\n```\r\n\r\n### Using Links to Server Routes\r\nLet's say you have a server route that you'd like to link to. For example, a\r\nfile download route which *has* to go to the server.\r\n\r\n```javascript\r\nRouter.route('/download/:filename', function () {\r\n  this.response.end('some file content\\n');\r\n}, {where: 'server'});\r\n```\r\n\r\nNow, in our html we'll have a link to download a particular file.\r\n\r\n```html\r\n<a href=\"/download/myfilename\">Download File</a>\r\n```\r\n\r\nWhen a user clicks on the `Download File` link, the router will send you to the\r\nserver and run the server-side route.\r\n\r\n## Named Routes\r\nRoutes can have names that can be used to refer to the route. If you don't give\r\nit a name, the router will guess its name based on the path. But you can provide\r\na name explicitly using the `name` option.\r\n\r\n```javascript\r\nRouter.route('/posts/:_id', function () {\r\n  this.render('Post');\r\n}, {\r\n  name: 'post.show'\r\n});\r\n```\r\n\r\nNow that we've named our route, we can get access to the route object if needed\r\nlike this:\r\n\r\n```javascript\r\nRouter.routes['post.show']\r\n```\r\n\r\nBut we can also use the route name in the `Router.go` method like this:\r\n\r\n```javascript\r\nRouter.go('post.show');\r\n```\r\n\r\nNow that we're using named routes in `Router.go` you can also pass a parameters\r\nobject, query and hash fragment options.\r\n\r\n```javascript\r\nRouter.go('post.show', {_id: 1}, {query: 'q=s', frag: 'hashFrag'});\r\n```\r\n\r\nThe above JavaScript will navigate to this url:\r\n\r\n```html\r\n/post/1?q=s#hashFrag\r\n```\r\n\r\n## Path and Link Template Helpers\r\n\r\n### pathFor\r\nThere are a few template helpers we can use to create links based on routes.\r\nFirst, we can use the `{{pathFor}}` helper to generate a path for a given named\r\nroute. Given the `post.show` route we created above we can create a link like\r\nthis:\r\n\r\n```html\r\n{{#with post}}\r\n  <a href=\"{{pathFor route='post.show'}}\">Post Show</a>\r\n{{/with}}\r\n```\r\n\r\nAssuming we have a post with an id of \"1\", the above snippet is equivalent to:\r\n\r\n```html\r\n<a href=\"/posts/1\">Post Show</a>\r\n```\r\n\r\nWe can pass `data`, `query` and `hash` options to the pathFor helper.\r\n\r\n```html\r\n<a href=\"{{pathFor route='post.show' data=getPost query='q=s' hash='frag'}}\">Post Show</a>\r\n```\r\n\r\nThe data object will be interpolated onto the route parameters. The query and\r\nhash arguments will be added to the href as a query string and hash fragment.\r\nLet's say our data object looks like this:\r\n\r\n```javascript\r\ndata = { _id: 1 };\r\n```\r\n\r\nThe above `pathFor` expression will result in a link that looks like this:\r\n\r\n```html\r\n<a href=\"/post/1?q=s#frag\">Post Show</a>\r\n```\r\n\r\nThe benefit of using the `pathFor` helper is that we don't need to keep hard\r\ncoded `href` attributes all over the application.\r\n\r\n\r\n### urlFor\r\nWhile the `pathFor` helper generates a path for the given route, `urlFor` will\r\ngenerate a fully qualified url. For example, `pathFor` might generate a path\r\nthat looks like `/posts/1` but `urlFor` would generate\r\n`http://mysite.com/posts/1`.\r\n\r\n### linkTo\r\nThe `linkTo` helper automatically generates the html for an anchor tag along\r\nwith the route path for the given route, parameters, hash and query. You can\r\neven provide a block of content to be used inside the link.\r\n\r\n```html\r\n{{#linkTo route=\"post.show\" data=getData query=\"q=s\" frag=\"hashFrag\" class=\"my-cls\"}}\r\n  <span style=\"color: orange;\">\r\n    Post Show\r\n  </span>\r\n{{/linkTo}}\r\n```\r\n\r\nThe expression above will be transformed into html that looks like this:\r\n\r\n```html\r\n<a href=\"/posts/1?q=s#hashFrag\" class=\"my-cls\">\r\n  <span style=\"color: orange;\">\r\n    Post Show\r\n  </span>\r\n</a>\r\n```\r\n\r\n## Route Options\r\nSo far you've seen a few options you can provide to routes like the `name`\r\noption. There are a few other options and several ways to provide options to\r\nroutes.\r\n\r\n### Route Specific Options\r\nIn this example we'll omit the route function and just provide an options\r\nobject. The options object will explain each of the possible options.\r\n\r\n```javascript\r\nRouter.route('/post/:_id', {\r\n  // The name of the route.\r\n  // Used to reference the route in path helpers and to find a default template\r\n  // for the route if none is provided in the \"template\" option. If no name is\r\n  // provided, the router guesses a name based on the path '/post/:_id'\r\n  name: 'post.show',\r\n\r\n  // To support legacy versions of Iron.Router you can provide an explicit path\r\n  // as an option, in case the first parameter is actually a route name.\r\n  // However, it is recommended to provide the path as the first parameter of the\r\n  // route function.\r\n  path: '/post/:_id',\r\n\r\n  // If we want to provide a specific RouteController instead of an anonymous\r\n  // one we can do that here. See the Route Controller section for more info.\r\n  controller: 'CustomController',\r\n\r\n  // If the template name is different from the route name you can specify it\r\n  // explicitly here.\r\n  template: 'Post',\r\n\r\n  // A layout template to be used with this route.\r\n  // If there is no layout provided, a default layout will\r\n  // be used.\r\n  layoutTemplate: 'ApplicationLayout',\r\n\r\n  // A declarative way of providing templates for each yield region\r\n  // in the layout\r\n  yieldRegions: {\r\n    'MyAside': {to: 'aside'},\r\n    'MyFooter': {to: 'footer'}\r\n  },\r\n\r\n  // Subscriptions or other things we want to \"wait\" on. More on waitOn in the\r\n  // next section.\r\n  waitOn: function () {\r\n    return Meteor.subscribe('post', this.params._id);\r\n  },\r\n\r\n  // A data function that can be used to automatically set the data context for\r\n  // our layout. This function can also be used by hooks and plugins. For\r\n  // example, the \"dataNotFound\" plugin calls this function to see if it\r\n  // returns a null value, and if so, renders the not found template.\r\n  data: function () {\r\n    return Posts.findOne({_id: this.params._id});\r\n  },\r\n\r\n  // You can provide any of the hook options described below in the \"Using\r\n  // Hooks\" section.\r\n  onRun: function () {},\r\n  onRerun: function () {},\r\n  onBeforeAction: function () {},\r\n  onAfterAction: function () {},\r\n  onStop: function () {},\r\n\r\n  // The same thing as providing a function as the second parameter. You can\r\n  // also provide a string action name here which will be looked up on a Controller\r\n  // when the route runs. More on Controllers later. Note, the action function\r\n  // is optional. By default a route will render its template, layout and\r\n  // regions automatically.\r\n  // Example:\r\n  //  action: 'myActionFunction'\r\n  action: function () {\r\n    // render all templates and regions for this route\r\n    this.render();\r\n  }\r\n});\r\n```\r\n\r\n### Global Default Options\r\nYou can set any of the above options on the Router itself. These become default\r\noptions for all of our routes. To set default Router options use the `configure`\r\nmethod.\r\n\r\n```javascript\r\nRouter.configure({\r\n  layoutTemplate: 'ApplicationLayout',\r\n\r\n  template: 'DefaultTemplate'\r\n\r\n  // .\r\n  // .\r\n  // .\r\n});\r\n```\r\n\r\nOptions declared on the route will override these default Router options.\r\n\r\n## Waiting on Subscriptions\r\nSometimes you want to wait on one or more subscriptions to be ready, or maybe\r\non the result of some other action. For example, you might want to show a\r\nloading template while waiting for subscription data.\r\n\r\n### Wait and Ready\r\n\r\nYou can use the `wait` method to add a subscription to the wait list. When you\r\ncall `this.ready()` it returns true if all items in the wait list are ready.\r\n\r\n```javascript\r\nRouter.route('/post/:_id', function () {\r\n  // add the subscription handle to our waitlist\r\n  this.wait(Meteor.subscribe('item', this.params._id));\r\n\r\n  // this.ready() is true if all items in the wait list are ready\r\n\r\n  if (this.ready()) {\r\n    this.render();\r\n  } else {\r\n    this.render('Loading');\r\n  }\r\n});\r\n```\r\n\r\nAn alternative way to write the above example is to call the `wait` method\r\non the subscription directly. In this case you'll call `this.subscribe` instead\r\nof `Meteor.subscribe`.\r\n\r\n```javascript\r\nRouter.route('/post/:_id', function () {\r\n  this.subscribe('item', this.params._id).wait();\r\n\r\n  if (this.ready()) {\r\n    this.render();\r\n  } else {\r\n    this.render('Loading');\r\n  }\r\n});\r\n```\r\n\r\n### Using waitOn\r\nIn the last two examples we populated the wait list in our route function. In\r\nmany cases this is okay. But if you're using hooks like \"loading\" or\r\n\"dataNotFound\" you may need the wait list to be populated before those hooks\r\nrun. In order to accomplish this you can use the `waitOn` option. Using `waitOn`\r\nmakes sure the wait list is populated before anything else runs.\r\n\r\n```javascript\r\nRouter.route('/post/:_id', {\r\n  waitOn: function () {\r\n    // return one handle, a function, or an array\r\n    return Meteor.subscribe('post', this.params._id);\r\n  },\r\n\r\n  action: function () {\r\n    // this.ready() is true if all items returned from waitOn are ready\r\n    if (this.ready())\r\n      this.render();\r\n    else\r\n      this.render('Loading');\r\n  }\r\n});\r\n```\r\n\r\n## Server Routing\r\n\r\n### Creating Routes\r\nSo far you've seen features mostly intended for the browser. But you can also\r\ncreate server routes with full access to the NodeJS request and response\r\nobjects. To create a server route you provide the `where: 'server'` option to\r\nthe route.\r\n\r\n```javascript\r\nRouter.route('/download/:file', function () {\r\n  // NodeJS request object\r\n  var request = this.request;\r\n\r\n  // NodeJS  response object\r\n  var response = this.response;\r\n\r\n  this.response.end('file download content\\n');\r\n}, {where: 'server'});\r\n```\r\n\r\n### Restful Routes\r\nYou can even create server-side restful routes which correspond to an http verb.\r\nThis is particularly useful if you're setting up a webhook for another service\r\nto post data to.\r\n\r\n```javascript\r\nRouter.route('/webhooks/stripe', { where: 'server' })\r\n  .get(function () {\r\n    // GET /webhooks/stripe\r\n  })\r\n  .post(function () {\r\n    // POST /webhooks/stripe\r\n  })\r\n  .put(function () {\r\n    // PUT /webhooks/stripe\r\n  })\r\n```\r\n\r\n### 404s and Client vs Server Routes\r\nWhen you initially navigate to your Meteor application's url, the server router\r\nwill see if there are any routes defined for that url, either on the server or\r\non the client. If no routes are found, the server will send a 404 http status\r\ncode to indicate no resource was found for the given url.\r\n\r\n### Server Middleware and Connect\r\nYou can attach middleware to the router on the server using the `use` method of\r\nthe router. And Connect middleware just works out-of-the-box. This is because\r\nthe `req, res, next` arguments are passed to the router handler functions like\r\njust in the Connect middleware stack. But typically we'll access those\r\nproperties using `this.request`, `this.response`, and `this.next` instead.\r\n\r\n```javascript\r\nif (Meteor.isServer) {\r\n  // assuming we've loaded a package with access to connect\r\n  var connect = Npm.require('connect');\r\n  Router.use(connect.queryParser(), {where: 'server'});\r\n}\r\n```\r\n\r\nYou could also create your own server-side middleware. For example, you might\r\nwant to log all http requests.\r\n\r\n```javascript\r\nRouter.use(function logHttpRequests () {\r\n  var method = this.method;\r\n  var url = this.url;\r\n  console.log(method + ' ' + url);\r\n\r\n  // go on to the next handler now\r\n  this.next();\r\n}, {where: 'server'});\r\n```\r\n\r\n## Plugins\r\nPlugins are a way to reuse functionality in your router, either that you've\r\nbuilt for your own applications, or from other package authors. There's even two\r\nbuilt-in plugins called \"loading\" and \"dataNotFound\".\r\n\r\nTo use a plugin just call the `plugin` method of Router and pass the name of the\r\nplugin and any options for the plugin.\r\n\r\n```javascript\r\nRouter.plugin('loading', {loadingTemplate: 'Loading'});\r\n```\r\n\r\nThis out-of-box plugin will automatically render the template named \"Loading\" if\r\nthe route's data is not ready (i.e. `this.ready() == false`).\r\n\r\n```javascript\r\nRouter.plugin('dataNotFound', {dataNotFoundTemplate: 'NotFound'});\r\n\r\nRouter.route('/post/:_id', {\r\n  data: function () {\r\n    // if this returns a falsy value like null, the NotFound template will\r\n    // render instead of our Post template.\r\n    return Posts.findOne({_id: this.params._id});\r\n  }\r\n});\r\n```\r\n\r\nThis plugin will render the \"NotFound\" template if your data function returns a\r\nfalsy value like null or false.\r\n\r\n### Creating Plugins\r\nTo create a plugin just put your function on the `Iron.Router.plugins` object\r\nlike this:\r\n\r\n```javascript\r\nIron.Router.plugins.loading = function (router, options) {\r\n  // this loading plugin just creates an onBeforeAction hook\r\n  router.onBeforeAction('loading', options);\r\n};\r\n```\r\nThe plugin function will get called with the router instance and any options the\r\nuser passed.\r\n\r\n*Package authors are encouraged to create new plugins!*\r\n\r\n## Hooks\r\n\r\n### Using Hooks\r\nA hook is just a function. Hooks provide a way to plug into the process of\r\nrunning a route, typically to customize rendering behavior or perform some\r\nbusiness logic.\r\n\r\nIn this example, our goal is to only render the template and regions for a route\r\nif the user is logged in. We'll add a hook function using the `onBeforeAction`\r\nmethod to tell the router we want this function to run before our route\r\nfunction, or the \"action\" function.\r\n\r\n```javascript\r\nRouter.onBeforeAction(function () {\r\n  // all properties available in the route function\r\n  // are also available here such as this.params\r\n\r\n  if (!Meteor.user()) {\r\n    // if the user is not logged in, render the Login template\r\n    this.render('Login');\r\n  } else {\r\n    // otherwise don't hold up the rest of hooks or our route/action function\r\n    from running\r\n    this.next();\r\n  }\r\n});\r\n```\r\n\r\nNow let's say we have a route defined like this:\r\n\r\n```javascript\r\nRouter.route('/admin', function () {\r\n  this.render('AdminPage');\r\n});\r\n```\r\n\r\nOur onBeforeAction hook function will run before our route function when the\r\nuser navigates to \"/admin\". If the user is not logged in, the route function\r\nwill never get called and the `AdminPage` will not render to the page.\r\n\r\nHook functions and all functions that get run when dispatching to a route are\r\nrun in a **reactive computation**: they will rerun if any reactive data sources\r\ninvalidate the computation. In the above example, if `Meteor.user()` changes the\r\nentire set of route functions will be run again.\r\n\r\n### Applying Hooks to Specific Routes\r\nYou can apply a hook to a specific route by passing an `except` or `only` option\r\nto the respective hook function.\r\n\r\n```javascript\r\nRouter.onBeforeAction(myAdminHookFunction, {\r\n  only: ['admin']\r\n  // or except: ['routeOne', 'routeTwo']\r\n});\r\n```\r\n\r\nIn the above example, the myAdminHookFunction will only get applied to a route\r\nnamed 'admin.'\r\n\r\n### Using the Iron.Router.hooks Namespace\r\nPackage authors can add hook functions to `Iron.Router.hooks` and users can\r\nreference those hooks by string name.\r\n\r\n```javascript\r\nIron.Router.hooks.customPackageHook = function () {\r\n  console.log('hi');\r\n  this.next();\r\n};\r\n\r\nRouter.onBeforeAction('customPackageHook');\r\n```\r\n### Available Hook Methods\r\n* **onRun**: Called when the route is first run. It is not called again if the\r\n  route reruns because of a computation invalidation.\r\n\r\n* **onRerun**: Called if the route reruns because its computation is\r\n  invalidated.\r\n\r\n* **onBeforeAction**: Called before the route or \"action\" function is run. These\r\n  hooks behave specially. If you want to continue calling the next function you\r\n  *must* call `this.next()`. If you don't, downstream onBeforeAction hooks and\r\n  your action function will *not* be called.\r\n\r\n* **onAfterAction**: Called after your route/action function has run or had a\r\n  chance to run. These hooks behave like normal hooks and you don't need to call\r\n  `this.next()` to move from one to the next.\r\n\r\n* **onStop**: Called when the route is stopped, typically right before a new\r\n  route is run.\r\n\r\n## Route Controllers\r\nAn `Iron.RouteController` object is created when the Router handles a url\r\nchange. The `RouteController` gives us a place to store state as we run the\r\nroute, and persists until another route is run.\r\n\r\nWe've been calling a few methods inside of our route functions like\r\n`this.render()` and `this.layout()`. The `this` object inside of these functions\r\nis actually an instance of a `RouteController`. If you're building a simple\r\napplication you probably don't need to worry about `RouteController`. But if\r\nyour application gets larger, using `RouteControllers` directly offers two key\r\nbenefits:\r\n\r\n* **Inheritance**: You can inherit from other RouteControllers to model your\r\n  application's behavior.\r\n* **Organization**: You can begin to separate your route logic into\r\n  RouteController files instead of putting all of your complex business logic\r\n  into one big route file.\r\n\r\n### Creating Route Controllers\r\nYou can create a custom `RouteController` like this:\r\n\r\n```javascript\r\nPostController = RouteController.extend();\r\n```\r\n\r\nWhen you define a route, you can specify a controller to use, or the router will\r\ntry to find a controller automatically based on the name of the route.\r\n\r\n```javascript\r\nRouter.route('/post/:_id', {\r\n  name: 'post'\r\n});\r\n```\r\n\r\nThe route defined above will automatically use the `PostController` using the\r\nname of the route. We can tell the route to use a different controller by\r\nproviding a controller option.\r\n\r\n```javascript\r\nRouter.route('/post/:_id', {\r\n  name: 'post.show',\r\n  controller: 'PostController'\r\n});\r\n```\r\n\r\nWe can use all of the same options from our routes on our `RouteControllers`.\r\n\r\n```javascript\r\nPostController = RouteController.extend({\r\n  layoutTemplate: 'PostLayout',\r\n\r\n  template: 'Post',\r\n\r\n  waitOn: function () { return Meteor.subscribe('post', this.params._id); },\r\n\r\n  data: function () { return Posts.findOne({_id: this.params._id}) },\r\n\r\n  action: function () {\r\n    this.render();\r\n  }\r\n});\r\n```\r\n\r\nWe might have some options defined globally with `Router.configure`, some\r\noptions defined on the `Route` and some options defined on the\r\n`RouteController`. Iron.Router looks up options in this order:\r\n\r\n1. RouteController\r\n2. Route\r\n3. Router\r\n\r\n### Inheriting from Route Controllers\r\nRouteControllers can inherit from other RouteControllers. This enables some\r\ninteresting organization schemes for your application.\r\n\r\nLet's say we have an `ApplicationController` which we want to use as the default\r\ncontroller for all routes.\r\n\r\n```javascript\r\nApplicationController = RouteController.extend({\r\n  layoutTemplate: 'ApplicationLayout',\r\n\r\n  onBeforeAction: function () {\r\n    // do some login checks or other custom logic\r\n    this.next();\r\n  }\r\n});\r\n\r\nRouter.configure({\r\n  // this will be the default controller\r\n  controller: 'ApplicationController'\r\n});\r\n\r\n// now we have a route for posts\r\nRouter.route('/posts/:_id', {\r\n  name: 'post'\r\n});\r\n\r\n// inherit from `ApplicationController` and override any\r\n// behavior you'd like.\r\nPostController = ApplicationController.extend({\r\n  layoutTemplate: 'PostLayout'\r\n});\r\n```\r\n\r\n\r\n\r\n*NOTE: This is currently a bit tricky with Meteor since you can't precisely\r\ncontrol file load order. You need to make sure parent RouteControllers are\r\nevaluated before child RouteControllers.*\r\n\r\n### Accessing the Current Route Controller\r\nThere are two ways to access the current `RouteController`.\r\n\r\nIf you're on the client, you can use the `Router.current()` method. This will\r\nreactively return the current instance of a `RouteController`. Keep in mind this\r\nvalue could be `null` if no route has run yet.\r\n\r\nYou can also access the current `RouteController` from inside your template\r\nhelpers by using the `UI.controller()` method.\r\n\r\n```javascript\r\nRouter.route('/posts', function () {\r\n  this.render('Posts');\r\n});\r\n```\r\n\r\nThis route will render the `Posts` template defined below.\r\n\r\n```html\r\n<template name=\"Posts\">\r\n  Posts\r\n</template>\r\n```\r\n\r\nNow let's say we want to access the current controller from a template helper\r\ndefined on the `Posts` template.\r\n\r\n```javascript\r\nTemplate.Posts.helpers({\r\n  myHelper: function () {\r\n    var controller = UI.controller();\r\n\r\n    // now we can get properties and call methods on the controller\r\n  }\r\n});\r\n```\r\n\r\n### Setting Reactive State Variables\r\nYou can set reactive state variables on controllers using the `set` method.\r\nLet's say we want to store the post `_id` in a reactive variable.\r\n\r\n```javascript\r\nRouter.route('/posts/:_id', {name: 'post'});\r\n\r\nPostController = RouteController.extend({\r\n  action: function () {\r\n    // set the reactive state variable \"postId\" with a value\r\n    // of the id from our url\r\n    this.set('postId', this.params._id);\r\n    this.render();\r\n  }\r\n});\r\n```\r\n\r\n### Getting Reactive State Variables\r\nYou can get a reactive variable value by calling `this.get(\"key\")` on the\r\n`RouteController`. Using the example above, let's grab the value of `postId`\r\nfrom a template helper.\r\n\r\n```javascript\r\nTemplate.Post.helpers({\r\n  postId: function () {\r\n    var controller = UI.controller();\r\n\r\n    // reactively return the value of postId\r\n    return controller.get('postId');\r\n  }\r\n});\r\n```\r\n\r\n## Custom Router Rendering\r\nSo far we've been letting the Router render itself to the page automatically.\r\nBut you can also control precisely where the Router renders itself by using a\r\nglobal helper method.\r\n\r\n```html\r\n<body>\r\n  <h1>Some App Html</h1>\r\n  <div class=\"container\">\r\n    {{! Render the router into this div instead of the body}}\r\n    {{> Router}}\r\n  </div>\r\n</body>\r\n```\r\n\r\n## Legacy Browser Support\r\nLegacy browsers do not support the HTML5 `pushState` and `history` features\r\nrequired for normal client side browsing with the `Router`. To solve this\r\nproblem, the `Router` can fall back to using hash fragments in the url.\r\nActually, under the hood, `iron-router` uses a package called `iron-location`\r\nwhich handles all of this. It works similarly to the `History.js` project but\r\nworks seamlessly.\r\n\r\nThis functionality is automatically enabled for **IE8** and **IE9**. If you want\r\nto enable it manually to play around you can configure `Iron.Location` like\r\nthis:\r\n\r\n```javascript\r\nIron.Location.configure({useHashPaths: true});\r\n```\r\n\r\nEven though the url will appear differently in the browser when using this mode,\r\nthe url, query, hash and parameters will look like their regular values inside\r\nof `RouteController` functions. Here are a few examples of how urls will be\r\ntranslated.\r\n\r\n```\r\nhttp://localhost:3000/items/5?q=s#hashFrag\r\n```\r\n\r\nThe url above would be transformed to the url below in your browser.\r\n\r\n```\r\nhttp://localhost:3000/#/items/5?q=s&__hash__=hashFrag\r\n```\r\n\r\nBut in your `RouteController` functions you can access the url, query and hash\r\nvalues just like you have before.\r\n\r\n```\r\nRouter.route('/items/:_id', function () {\r\n  var id = this.params._id; // \"5\"\r\n  var query = this.params.query; // {q: \"s\"}\r\n  var hash = this.params.hash; // \"hashFrag\"\r\n});\r\n```\r\n\r\n**NOTE: Please let us know if you can help test support on other browsers!**\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}